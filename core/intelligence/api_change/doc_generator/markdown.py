"""
Markdown Documentation Generator

Generates incremental markdown documentation for API changes
"""

from typing import List, Dict, Any
from datetime import datetime
from pathlib import Path
import logging

from ..models.api_change import APIChangeEvent, DiffResult

logger = logging.getLogger(__name__)


class MarkdownGenerator:
    """Generate incremental Markdown documentation"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.output_dir = Path(config.get("output_dir", "docs/api-changes"))
        
        markdown_config = config.get("formats", {}).get("markdown", {})
        self.output_file = markdown_config.get("file", "api-changes.md")
        self.append_mode = markdown_config.get("append_mode", True)
    
    def generate(self, result: DiffResult):
        """Generate markdown documentation for diff result"""
        logger.info(f"Generating markdown documentation...")
        
        self.output_dir.mkdir(parents=True, exist_ok=True)
        output_path = self.output_dir / self.output_file
        
        content = self._build_content(result)
        
        if self.append_mode and output_path.exists():
            # Append to existing file
            with output_path.open("a", encoding="utf-8") as f:
                f.write("\n\n---\n\n")
                f.write(content)
            logger.info(f"Appended to: {output_path}")
        else:
            # Create new file
            with output_path.open("w", encoding="utf-8") as f:
                f.write(self._build_header())
                f.write(content)
            logger.info(f"Created: {output_path}")
    
    def _build_header(self) -> str:
        """Build document header"""
        return f"""# API Change Log

**Generated by CrossBridge AI - API Change Intelligence**

This document tracks all API changes detected by analyzing OpenAPI/Swagger specifications.

---

"""
    
    def _build_content(self, result: DiffResult) -> str:
        """Build content for a single diff result"""
        timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
        
        content = f"""## API Changes â€“ {timestamp}

**Run ID:** `{result.run_id}`

**Spec Versions:**
- Previous: `{result.old_spec_version}`
- Current: `{result.new_spec_version}`

**Summary:**
- âœ… Total Changes: **{result.total_changes}**
- âš ï¸ Breaking Changes: **{result.breaking_changes}**
- ğŸ”¥ High Risk Changes: **{result.high_risk_changes}**
- â• Added Endpoints: {result.added_endpoints}
- ğŸ”„ Modified Endpoints: {result.modified_endpoints}
- âŒ Removed Endpoints: {result.removed_endpoints}
"""
        
        if result.ai_enabled and result.ai_tokens_used > 0:
            content += f"- ğŸ¤– AI Tokens Used: {result.ai_tokens_used}\n"
        
        content += f"\n**Analysis Duration:** {result.duration_ms}ms\n\n"
        
        if not result.changes:
            content += "### âœ… No Changes Detected\n\n"
            return content
        
        # Group changes by type
        added = [c for c in result.changes if c.change_type.value == "added"]
        modified = [c for c in result.changes if c.change_type.value == "modified"]
        removed = [c for c in result.changes if c.change_type.value == "removed"]
        
        # Added endpoints/schemas
        if added:
            content += "### â• Added\n\n"
            content += self._format_changes(added)
        
        # Modified endpoints/schemas
        if modified:
            content += "### ğŸ”„ Modified\n\n"
            content += self._format_changes(modified)
        
        # Removed endpoints/schemas
        if removed:
            content += "### âŒ Removed\n\n"
            content += self._format_changes(removed)
        
        # Breaking changes section
        breaking = [c for c in result.changes if c.breaking]
        if breaking:
            content += "### âš ï¸ Breaking Changes\n\n"
            content += "These changes may break existing clients:\n\n"
            for change in breaking:
                content += f"#### {change.entity_name}\n\n"
                content += f"- **Type:** {change.entity_type.value.title()}\n"
                content += f"- **Risk:** {change.risk_level.value.upper()}\n"
                if change.http_method and change.path:
                    content += f"- **Endpoint:** `{change.http_method} {change.path}`\n"
                if change.recommended_tests:
                    content += f"- **Action Required:**\n"
                    for test in change.recommended_tests[:3]:
                        content += f"  - {test}\n"
                content += "\n"
        else:
            content += "### âœ… No Breaking Changes\n\n"
        
        # High-risk changes
        high_risk = [c for c in result.changes if c.risk_level.value in ["high", "critical"] and not c.breaking]
        if high_risk:
            content += "### ğŸ”¥ High Risk Changes (Non-Breaking)\n\n"
            for change in high_risk:
                content += f"- **{change.entity_name}** ({change.risk_level.value})\n"
                if change.ai_enhanced and change.ai_reasoning:
                    content += f"  - ğŸ¤– AI Analysis: {change.ai_reasoning}\n"
                if change.impacted_areas:
                    content += f"  - Impact: {', '.join(change.impacted_areas[:3])}\n"
                content += "\n"
        
        return content
    
    def _format_changes(self, changes: List[APIChangeEvent]) -> str:
        """Format a list of changes"""
        content = ""
        
        for change in changes:
            # Entity name with method/path
            if change.http_method and change.path:
                content += f"#### `{change.http_method} {change.path}`\n\n"
            else:
                content += f"#### {change.entity_name}\n\n"
            
            # Risk badge
            risk_emoji = {
                "low": "ğŸŸ¢",
                "medium": "ğŸŸ¡",
                "high": "ğŸ”´",
                "critical": "âš«"
            }
            content += f"- **Risk:** {risk_emoji.get(change.risk_level.value, 'âšª')} {change.risk_level.value.upper()}\n"
            
            # Breaking badge
            if change.breaking:
                content += "- **âš ï¸ BREAKING CHANGE**\n"
            
            # AI enhancement badge
            if change.ai_enhanced:
                content += "- **ğŸ¤– AI Enhanced**\n"
            
            # Entity type
            content += f"- **Type:** {change.entity_type.value.title()}\n"
            
            # Recommended tests
            if change.recommended_tests:
                content += "- **Recommended Tests:**\n"
                for test in change.recommended_tests[:5]:  # Limit to 5
                    content += f"  - {test}\n"
            
            # Impacted areas
            if change.impacted_areas:
                content += f"- **Impacted Areas:** {', '.join(change.impacted_areas[:5])}\n"
            
            # Edge cases
            if change.edge_cases:
                content += f"- **Edge Cases to Test:** {', '.join(change.edge_cases[:3])}\n"
            
            content += "\n"
        
        return content
